/************************************************************************************************
------------------------------------------------------------------------------------------------
On the use of vec4:
GLSL assigns every value (int, bool, float, char, etc.) a 16-byte value.  This demo program is 
in 2D only, so I only need a vec2 for all the points that I need, but simply adding 2 floats of 
padding to the corresponding vec2 structures on the CPU side didn't seem to line them up.  So I
decided to use a vec4 for all my points.  It made my life easier.

------------------------------------------------------------------------------------------------
On specifying the work item count:
Ex: layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

This demo program goes through a large array of particles, but a whole bunch of shader instances 
are running at one time.  Compute shaders introduce order by keeping track of a 3D work item 
count.  For each work group, the number of which is specified on the CPU side of the program 
when the compute shader is summoned, all the work items will be called.  

For example, supposed there are 10,000 particles in the array.  The compute shader is kicked 
into gear by 
glDispatchCompute(numWorkGroupsX, numWorkGroupsY, and numWorkGroupsZ).  
Since compute shaders are often used to compute for 3D gaming or rendering environments, this 
made sense to the creators of the OpenGL compute shader standard.  

Now suppose that I want to make 256 particles on each compute thread.  Then 
10,000 / 256 = ~39 work groups.  This means (??you sure??) that there will be 39 parallel 
threads of this shader and the GPU will schedule them whenever it can.  At the time of this 
comment (9-3-2016), there doesn't seem to be an optimal number of work groups 
(http://gamedev.stackexchange.com/questions/66198/optimal-number-of-work-groups-for-compute-shaders).  

When I specify the layout, I must use this same number (256).  To get 10,000 work items 
(individual calls to the compute shader's main()), then I must do this:
CPU code: glDispatchCompute(39, 1, 1);
GPU code: layout (local_size_x = 256, local_size_y = 1, local_size_z = 1);
Equivalent GPU code: layout (local_size_x = 256);

The global work item number for any given call to the compute shader's main() is 
"local work group number * local work item number".  
Ex: Suppose the GPU is working on work group 24 (out of 39), and this thread is on invocation 
159 (out of 256).  Then the global work item number is 24 * 159 = 3816.

From the OpenGL ARB (Architecture Review Board): 
    https://www.opengl.org/registry/specs/ARB/compute_shader.txt
        The built-in variable <gl_LocalInvocationID> is a compute-shader input
    variable containing the 3-dimensional index of the local work group
    within the global work group that the current invocation is executing in.
    The possible values for this variable range across the local work group
    size, i.e. (0,0,0) to (gl_WorkGroupSize.x - 1, gl_WorkGroupSize.y - 1,
    gl_WorkGroupSize.z - 1).

The "invocation ID" (the global work item number) starts at 0, so it is therefore suitable as an 
index.  Now I can use the work item number as an index into the particle array.  

Now why "x"?  Because I decided to use the X axis in the compute shader.  I could have done it 
with Y or Z or did some kind of computation to work out an index into the particle array, but it 
was easier to just use one axis of the compute shader for a 1D array.

I could call "*.y" or "*.z", but that wouldn't be helpful size the layout specifies those as 1.  
According to the equation given earlier for the work item number and the "local size" of Y and Z 
being 1, the global work item on Y and Z will always be "work group * 1".  That means only 40 
work items in this example.  Not helpful when I have 10,000 particles.  

Anyway, to get the global work item number for an individual call to the compute shader's 
main(), I call this:
uint i = gl_GlobalInvocationID.x;

Problem: This example will only summon 39 * 256 = 9,984 work items.  This is less than the size 
of the particle array, so if I use the work item number as the index, some particles will never 
be accessed.  
Solution: On the CPU it is good practice to instead do this:
(10,000 / 256) + 1 = ~40.  And 40 * 256 = 10,240 work items.  This is greater than the array 
size, so now I need to ignore work item numbers that exceed the max index.

Then I use a uniform to tell me how many particles are actually in the array.  I compare the 
work item number against it, and if it exceeds the total number of particles, then the shader 
doesn't do anything.  Will there be some wasted calls?  Sure, but the GPU keeps its cores busy 
with other calls, so it isn't much of a performance loss.

Sample code:

uniform uint uMaxParticleCount;
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uMaxParticleCount)
    {
        // do the thing
    }
    else
    {
        // nothing to do, so this GPU core immediately returns and moves on to the next job
    }
}

------------------------------------------------------------------------------------------------
On accessing and changing items in a buffer:
I specify a single buffer in this manner:

layout (binding = 0) buffer ParticleBuffer {
    Particle AllParticles[];
};

This is a special buffer called a Uniform Buffer Object (UBO).  In this demo, the uniform buffer 
object contains a large, 1D array of data formatted after the Particle structure.  I could have 
told this shader that the data is formatted differently and it would have believed me, but then 
the bytes wouldn't line up and it would be useless.

Anyway.  There are no pointers or references in GLSL.  Everything is copy only, which is a good 
thing during parallel workloads because it means that you have to be very deliberate to intrude 
on another thread's working data.

To change a particle:
Particle p = AllParticles[someIndex];
...change particle data...
AllParticles[theSameIndex] = p;

Where "someIndex" is the global work item assigned to this particular invocation of the compute 
shader's main().  If I access any other index, then I am running over another thread's work.  

Multithread responsibly.


************************************************************************************************/


#version 440

// indices (that is, work item #) for the particle array
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// this must match the layout of the Particle structure defined on the CPU side
struct Particle
{
    vec4 _pos;
    vec4 _vel;
    int _isActive;
};

// like Particle, this must also match the memory layout defined on the CPU side
struct PolygonFace
{
    vec4 _p1;
    vec4 _p2;
    vec4 _normal;
};

uniform uint uParticleCount;

// Note: According to the documentation for shader storage buffer objects, "there can only be 
// one array of variable size per SSBO and it has to be the bottommost in the layout definition."
// See here: https://www.opengl.org/wiki/Shader_Storage_Buffer_Object.
layout (binding = 0) buffer ParticleBuffer 
{
    Particle AllParticles[];
};

// every particle needs to be checked against every face of the polygon, and I need to know the 
// size of the PolygonRegionFaces array in order to loop through them
uniform uint uPolygonFaceCount;
layout (binder = 1) buffer FaceBuffer
{
    PolygonFace PolygonRegionFaces[];
}


uniform float uDeltaTimeSec;


// FUNCTIONS 
// because GLSL doesn't have a #include and I either need to jump through some hoops to add a bunch of different shader files together (not too difficult, but determined to be better for this particular demo to have all the functions in one file)


/************************************************************************************************
Description:
    Found online: 
    http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner

    This is only as random as the input.  It is a hash function.  It generates a large fraction, 
    then uses fract(...) to get a number between -0.99... and +0.99...
Parameters:
    co      I don't know what this stands for, but it was in the source code.
            Note: I changed the input from the source's vec2 to a vec4 because everything else 
            uses a vec4 in this program.
Returns:
    A random float on the range [-0.99..., +0.99...];
Creator:    Unknown
************************************************************************************************/
float RandHash(vec4 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// because I only need the square of the radius for my boundary check
uniform float uRadiusSqr;
uniform vec4 uParticleRegionCircleCenter;

///************************************************************************************************
//Description:
//    Checks if the provided particle has gone outside of a circle defined by a uniform center and 
//    a uniform radius.
//
//    Why uniforms?  Because this function's cousin, "particle out of bounds polygon" cannot take 
//    a buffer as an argument and so must rely on a uniform buffer object and other uniforms, so I 
//    decided to make this function also use the same handicap.  It makes the coding consistent.
//Parameters:
//    p       A Particle instance.  It is not a reference or a pointer, but a copy.  It can 
//            therefore be used as a local variable, but as a matter of personal coding principle, 
//            I do not use an argument as a local variable.
//Returns:
//    True if the particle is outside the circle's bounds, otherwise false.
//Creator:    John Cox, 9-3-2016
//************************************************************************************************/
//bool ParticleOutOfBoundsCircle(Particle p)
//{
//    vec4 particleToRegionCenter = p._pos - uParticleRegionCircleCenter;
//    float distSqr = dot(particleToRegionCenter, particleToRegionCenter);
//
//    if (distSqr > uRadiusSqr)
//    {
//        return true;
//    }
//
//    // still in bounds
//    return false;
//}

/************************************************************************************************
Description:
    Checks if the provided particle has gone outside of any of the faces of the polygon region
    that is defined in the PolygonRegionFaces array.  

    Note: This algorithm only works on concave polygons.  That is, it only works on a polygon in 
    which all face normals point roughly towards the center.  The algorithm simply checks if a 
    vector from the face center to the particle's position is more than 90 degrees away from the 
    face normal.
Parameters:
    p       A Particle instance.  It is not a reference or a pointer, but a copy.  It can 
            therefore be used as a local variable, but as a matter of personal coding principle, 
            I do not use an argument as a local variable.
Returns:
    True if the particle is out of bounds, otherwise false.
Creator:    John Cox, 9-5-2016
************************************************************************************************/
bool ParticleOutOfBoundsPolygon(Particle p)
{
    for (int faceIndex = 0; faceIndex < uPolygonFaceCount; faceIndex++)
    {
        PolygonFace f = PolygonRegionFaces[faceIndex];

        vec4 faceToParticle = p._pos - f._centerPoint;
        if (dot(faceToParticle, f._normal) < 0))
        {
            return true;
        }
    }

    return false;
}


uniform vec4 uPointEmitterCenter;

/************************************************************************************************
Description:
    Resets the provided particle:
    (1) Sets its location to that of the point particle emitter (a uniform).
    (2) Sets its velocity to a random 2D direction.

    If the particle is only passed by copy and the reset position is set in stone and the 
    velocity is random, why is there an argument at all?  Because the random velocity 
    calculation is actually a choatic hash function and not entirely random.  The particle's 
    most likely unique floating point values are needed to seed that chaotic hash function.
Parameters:
    p       A Particle instance.  
Returns:
    A Particle with a position at the point emitter's location and a random 2D velocity.
Creator:    John Cox, 9-3-2016
************************************************************************************************/
Particle PointEmitterResetPos(Particle p)
{
    // there is enough chaos in the random number generator for just a change in 1 to create a 
    // very different number
    vec4 seed1 = vec4(p._pos.x + 1.0, p._pos.y, 0.0, 0.0);
    vec4 seed2 = vec4(p._pos.x, p._pos.y + 1.0, 0.0, 0.0);
    vec4 seed3 = vec4(p._vel.x, p._vel.y, 0.0, 0.0);
    float velX = RandHash(seed1);
    float velY = RandHash(seed2);

    // the "random" function returns a value on the range [-0.99..., +0.99...], and those limits 
    // are the same as window space ([-1,+1]), which this demo is running in, so cut the random 
    // range down so that the upper limits won't make ludicrously fast particles
    float variance = 0.05 * RandHash(seed3);

    // arguments are passed by value in GLSL, so I could use the argument as a local variable, 
    // but that code would smell funny, so I'll make a local copy of it 
    Particle pCopy = p;
    pCopy._pos = uPointEmitterCenter;
    pCopy._vel = variance * normalize(vec4(velX, velY, 0.0, 0.0));

    return pCopy;
}


uniform vec4 uBarP1;
uniform vec4 uBarP2;

//// TODO: header
//Particle BarEmitterReset(Particle p)
//{
//}




void main()
{
    // get the particle that this particular invocation will be working on
    // Note: See explanation of the "work item number" layout for more detail.
    uint index = gl_GlobalInvocationID.x;
    if (index < uParticleCount)
    {
        Particle p = AllParticles[index];

        // update position
        vec4 deltaPosition = p._vel * uDeltaTimeSec;
        p._pos = p._pos + deltaPosition;

        // if it went out of bounds, reset it
        if (ParticleOutOfBoundsPolygon(p))
        {
            PointEmitterResetPos(p);
        }

        //need multiple emitters
        //need to make another shader for the particle updater (just do the one)
        //need to make another shader for a circular particle region
        //need to make another shader for a polygon particle region
        //need to make another shader for a point emitter
        //need to make another shader for a bar emitter
        //need to only allow a set number of particle emitters
        //need a uniform to say how many emitters there are 
        //need to make a float uniform for each emitter with the fraction of the particles that each emitter will handle
        //updating:
        //- emitters are added on the CPU side and then copied to the GPU, so let fractional responsibilities be normalized there
        //- let there be a buffer of counters, one for each emitter, that can be updated by each particle emission, thus allowing the particles to be spread out in a user-specified fraction amongst all the emitters (??can each update be seen by other work items? perhaps the "atomic counter"??)

        // copy it back in
        AllParticles[index] = p;
    }
}

