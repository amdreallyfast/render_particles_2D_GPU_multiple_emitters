#version 440

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

/*-----------------------------------------------------------------------------------------------
Description:
    Stores info about a single particle.  Must match the version on the CPU side.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
struct Particle
{
    vec4 _pos;
    vec4 _vel;
    int _isActive;
};

/*-----------------------------------------------------------------------------------------------
Description:
    OpenGL rendering uses the same "Polygon Face" buffer, and OpenGL rendering takes vertices 
    one at a time.  I originally tried making each face into a single structure with two 
    positions and one normal, but then the rendering treated the whole thing like a single 
    vertex.  Whoops.  So I have to specify each vertex individually for the sake of rendering 
    and then match that here in the compute shader.
    
    Must match the version on the CPU side.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
struct MyVertex
{
    vec4 _pos;
    vec4 _normal;
};

/*-----------------------------------------------------------------------------------------------
Description:
    This demo is in 2D, so each polygon face is described by two vertices.  In 3D, this 
    structure will be updated to contain three.
    
    Must match the version on the CPU side.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
struct PolygonFace
{
    MyVertex _start;
    MyVertex _end;
};


/*-----------------------------------------------------------------------------------------------
Description:
    This is the array of particles that the compute shader will be accessing.  It is set up on 
    the CPU side in ParticleSsbo::Init(...).

    Note: Instead of the hard-coded binding point as was used in the "render particles 2D basic" 
    project, the binding point is determined on the CPU side.  Is that necessary in this demo?  
    No.  Binding points are relevant only to a particular shader and the CPU side needs to, at 
    least, tell OpenGL that the just-created SSBO should be bound to the same binding point 
    ("binding = 0" here in the shader means glBindBufferBase(..., 0, ...0 in the SSBO setup), 
    but if the user doesn't want to handle the binding on both the shader side and the CPU side, 
    then this demo shows how to handle binding entirely on the CPU side.
    
    Also Note: Without the binding point specifier, which implicitly assumed std430, then the 
    layout standard needs to be specified explicitly.  According to this website under heading 
    "Layout std430, new and better std140", std430 is the ONLY layout specifier available for 
    SSBOs.  I don't know what it does, but it is necessary.  
    http://malideveloper.arm.com/resources/sample-code/introduction-compute-shaders-2/
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform uint uMaxParticleCount;
layout (std430) buffer ParticleBuffer
{
    // Note: According to the documentation for shader storage buffer objects, "there can only 
    // be one array of variable size per SSBO and it has to be the bottommost in the layout 
    // definition."  This means that, if I wanted to define anything else in here (I don't since 
    // it is an array of Particle structures whose size is determined on the CPU side), then I 
    // would have to declare it before the array.  If I declared it after, then the shader won't 
    // compile.
    // See here: https://www.opengl.org/wiki/Shader_Storage_Buffer_Object.
    Particle AllParticles[];
};

/*-----------------------------------------------------------------------------------------------
Description:
    This is the array of polygon faces that the compute shader will access for bounds checking.  
    It is set up on the CPU side in PolygonSsbo::Init(...).
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform uint uPolygonFaceCount;
layout (std430) buffer FaceBuffer
{
    PolygonFace PolygonRegionFaces[];
};

/*-----------------------------------------------------------------------------------------------
Description:
    A convenience function whose name indicates its purpose.  Also useful so that I don't have 
    to type the actual vector name three times.  This isn't quite as accurate as a real square 
    root, but from what I've read, it is pretty accurate out to a few decimal places, so it's 
    good enough for simulation work.
Parameters:
    v   The vec4 to be normalized.
Returns:
    A normalized copy of input v;
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
vec4 QuickNormalize(vec4 v)
{
    return inversesqrt(dot(v, v)) * v;
}

/*-----------------------------------------------------------------------------------------------
Description:
    Helps to generate a random displacement region around a particle's spawn point.  It gives 
    the illusion that the particles come from a cloud instead of a point.  It's a "looks nice" 
    feature.
Parameters:
    v1              The start of the linear blend.
    v2              The end of the linear blend.
    Between0And1    Some fraction of the difference between v1 and v2.
Returns:
    A vec4 that is linearly blended according to Between0and1.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
vec4 LinearMix(vec4 v1, vec4 v2, float Between0And1)
{
    return (v1 * (1 - Between0And1)) + (v2 * Between0And1);
}

/*-----------------------------------------------------------------------------------------------
Description:
    Found online:
    http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner

    Like rand() on the CPU side, this is a chaotic hash function whose output is only as random 
    as the input.  Calling it multiple times with the same input will always generate the same 
    output.  But unlike rand(), this function does not have access to OS-level calls to the 
    CPU's clock counter, nor is there access to any of the GPU's clock counters, so inputs must 
    be provided by ourselves.

    Note: This restriction on GLSL randomness is why the particles all need to be initialized 
    on the CPU side with non-0 values.  I tried all 0s.  The particles kept getting "random" 
    new velocities of 0.
Parameters:
    co  A vec2 seed.  The algorithm that I found online used a vec2, and I didn't change that.  ??how to make use of a vec4? what numbers do I add to the dot??
Returns:
    A semi-random float.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
float RandHash(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

/*-----------------------------------------------------------------------------------------------
Description:
    A convenience function that uses RandHash(...) to generate a random number on the range 
    [0,+1] (I think; I don't know if it actually hits 0 or +1).
Parameters:
    hashInput   A vec2 seed.  Needed by RandHash(...).
Returns:
    A semi-random float on the range [0,+1].
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
float RandomOnRange0To1(vec2 hashInput)
{
    return RandHash(hashInput);
}

/*-----------------------------------------------------------------------------------------------
Description:
    Another convenience function that uses RandHash(...), this time using two hash seeds to 
    generate a single number on the range [-1,+1] (again, I don't know if it actually hits -1 or 
    +1 exactly).  It is used to generate random X and Y velocity vectors for newly-eminating 
    particles.  If both hash seeds are the same, then the resulting particles only tend to spray 
    off in roughly 4 different cones that roughly correspond to the diagonals on an X-Y 2D grid. 
    So give it different inputs :).
Parameters:
    hashInput1  A vec2 seed.  Needed by RandHash(...).
    hashInput2  Another vec2 seed.
Returns:
    A semi-random float on the range [-1,+1].
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
float RandomOnRangeNeg1ToPos1(vec2 hashInput1, vec2 hashInput2)
{
    if (RandomOnRange0To1(hashInput1) < 0.5)
    {
        return -1.0 * RandomOnRange0To1(hashInput2);
    }
    else
    {
        return +1.0 * RandomOnRange0To1(hashInput2);
    }
}

/*-----------------------------------------------------------------------------------------------
Description:
    Checks if the provided particle has gone outside of any of the faces specified in the 
    PolygonRegionFaces buffer.

    Note: This algorithm only works on concave polygons.  That is, it only works on a polygon in 
    which all face normals point roughly towards the center.  This algorithm simply checks if a 
    vector from the face (either start or end; both work) to the particle's position is more 
    than 90 degrees away the face normal.
Parameters:
    p   A Particle instance.  It is not a reference or a pointer (GLSL doesn't do either), but a 
        copy.  If can therefore be used as a local variable, but as a matter of personal coding 
        principle, I do not use an argument as a local variable.
Returns:
    A semi-random float on the range [-1,+1].
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform mat4 uWindowSpaceRegionTransform;
bool ParticleOutOfBoundsPolygon(Particle p)
{
    for (int faceIndex = 0; faceIndex < uPolygonFaceCount; faceIndex++)
    {
        PolygonFace f = PolygonRegionFaces[faceIndex];

        // for this simple calculation, either the face's start or end point will work
        vec4 faceToParticle = p._pos - (uWindowSpaceRegionTransform * f._start._pos);
        vec4 rotatedNormal = uWindowSpaceRegionTransform * f._start._normal;
        if (dot(faceToParticle, rotatedNormal) > 0)
        {
            return true;
        }
    }

    return false;
}

// these two are used to give the particles a min velocity plus a fraction of the min-max delta, 
// and it is used in both particle emitters (point emitter and bar emitter)
uniform float uMinParticleVelocity;
uniform float uDeltaParticleVelocity;


/*-----------------------------------------------------------------------------------------------
Description:
    Resets a particle to a point emitter's position plus a variation on the position that gives
    the particles the appearance of eminating from a cloud (looks nicer than eminating from a
    point).

    Several random values are required during the reset to give the particles random starting 
    position and random velocity, so a bunch of RandHash(...) seeds are generated from the 
    particle's position and velocity.  This is why the particles must be initialized with 
    non-0 values (from experience: starting with 0 values causes RandHash(...) to spit out 0s 
    and then the particles don't do anything...whoops).
Parameters:
    p   A Particle instance.  
Returns:
    A Particle object with a random 2D velocity and a position that is the point emitter's 
    position plus a small variation on that position to give the appearance of spawning in a 
    particle cloud.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform vec4 uPointEmitterCenter;
uniform mat4 uWindowSpaceEmitterTransform;
Particle PointEmitterResetPos(Particle p)
{
    // need a lot of differnt seeds for the "random" hash
    // Note: If the same seed is used for multiple hash summons, such as 
    // RandomOnRangeNeg1ToPos1(...), then the result will be random-ish on a limited range 
    // (learned by experience) and doesn't look good.  So I use a lot of variations of the 
    // position and velocity to generate varying hash seeds.
    vec2 posSeed1 = vec2(p._pos.x + 0.0, p._pos.y + 0.0);
    vec2 posSeed2 = vec2(p._pos.x + 1.0, p._pos.y + 0.0);
    vec2 posSeed3 = vec2(p._pos.x + 0.0, p._pos.y + 1.0);
    vec2 posSeed4 = vec2(p._pos.x + 1.0, p._pos.y + 1.0);
    vec2 velSeed1 = vec2(p._vel.x + 0.0, p._vel.y + 0.0);
    vec2 velSeed2 = vec2(p._vel.x + 1.0, p._vel.y + 0.0);
    vec2 velSeed3 = vec2(p._vel.x + 0.0, p._vel.y + 1.0);
    vec2 velSeed4 = vec2(p._vel.x + 1.0, p._vel.y + 1.0);
    vec2 posVelSeed1 = vec2(p._pos.x + 0.0, p._vel.x + 0.0);
    vec2 posVelSeed2 = vec2(p._pos.x + 1.0, p._vel.x + 0.0);
    vec2 posVelSeed3 = vec2(p._pos.x + 0.0, p._vel.x + 1.0);
    
    Particle pCopy = p;
    
    vec4 basePosition = uWindowSpaceEmitterTransform * uPointEmitterCenter;
    //vec4 basePosition = uPointEmitterCenter;
    float posX = RandomOnRangeNeg1ToPos1(posSeed1, posSeed2);
    float posY = RandomOnRangeNeg1ToPos1(posSeed3, posSeed4);

    // need to normalize the outer limit (), but to do that we can't have a 1 in the w position 
    // or else the X and Y's normalization get's messed up
    // Note: Window space is on the range [-1,+1] on X and Y, hence the normalizing.
    // Also Note: Anything with w = 1 is meant to be translated but not normalized, while any 
    // vector with w = 0 is the reverse.
    vec4 outerPosLimit = 0.1 * QuickNormalize(vec4(posX, posY, 0.0, 0.0));
    vec4 posVariance = LinearMix(uPointEmitterCenter, outerPosLimit, 
        RandomOnRange0To1(posVelSeed1));
    pCopy._pos = basePosition + posVariance;
    
    // similar to the MinMaxVelocity::GetNew() on the CPU side
    float velocityVariation = RandomOnRange0To1(posVelSeed2) * uDeltaParticleVelocity;
    float velocityMagnitude = uMinParticleVelocity + velocityVariation;
    float velX = RandomOnRangeNeg1ToPos1(velSeed1, velSeed2);
    float velY = RandomOnRangeNeg1ToPos1(velSeed3, velSeed4);
    vec4 randomVelocityVector = QuickNormalize(vec4(velX, velY, 0.0, 0.0));
    pCopy._vel = randomVelocityVector * velocityMagnitude;
    
    return pCopy;
}


/*-----------------------------------------------------------------------------------------------
Description:
    Like PointEmitterResetPos(...), but for a bar emitter.
Parameters:
    p   A Particle instance.  
Returns:
    A Particle object with a random 2D velocity and a position randomly placed between the bar 
    emitter's start and end point.
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
uniform vec4 uBarEmitterP1;
uniform vec4 uBarEmitterP2;
Particle BarEmitterResetPos(Particle p)
{
    return p;
}

uniform float uDeltaTimeSec;

// this value is used to prevent uMaxParticleCount particles from being emitted all at once
// Note: This is used when the particles are spread out on multiple emitters.
uniform uint uMaxParticleEmitCount;

uniform uint uUsePointEmitter;
uniform uint uOnlyResetParticles;

// unlike the ParticleBuffer and FaceBuffer, atomic counter buffers seem to need a declaration 
// like this and cannot be bound dynamically as in ParticleSsbo and PolygonSsbo
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = 0, offset = 0) uniform atomic_uint ac;

/*-----------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator: John Cox (9-25-2016)
-----------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uMaxParticleCount)
    {
        Particle p = AllParticles[index];

        if (uOnlyResetParticles == 1)
        {
            if (p._isActive == 0)
            {
                // only reactivate the particle if there is enough left in the particle limit for 
                // this update
                if (atomicCounterIncrement(ac) < uMaxParticleEmitCount)
                {
                    if (uUsePointEmitter == 1)
                    {
                        // use the point emitter with whatever point was uploaded
                        p = PointEmitterResetPos(p);
                    }
                    else
                    {
                        // use bar emitter
                    }
                
                    p._isActive = 1;
                }
            }
        }
        else
        {
            // only update active particles 
            if (p._isActive == 1)
            {
                vec4 deltaPosition = p._vel * uDeltaTimeSec;
                p._pos = p._pos + deltaPosition;

                // if it went out of bounds, reset it
                if (ParticleOutOfBoundsPolygon(p))
                {
                    p._isActive = 0;
                }                
            }
        }

        AllParticles[index] = p;
    }
}

