#version 440

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// TODO: have "previous pos" too and use that to calculate the point of crossing the face
struct Particle
{
    vec4 _pos;
    vec4 _vel;
    int _isActive;
};

struct MyVertex
{
    vec4 _pos;
    vec4 _normal;
};

struct PolygonFace
{
    MyVertex _start;
    MyVertex _end;
};

uniform uint uMaxParticleCount;
uniform uint uParticleOffsetCount;  // used with multiple emitters working on different particles
layout (binding = 0) buffer ParticleBuffer 
{
    Particle AllParticles[];
};

uniform uint uPolygonFaceCount;
layout (binding = 1) buffer FaceBuffer
{
    PolygonFace PolygonRegionFaces[];
};


vec4 QuickNormalize(vec4 v)
{
    return inversesqrt(dot(v, v)) * v;
}

vec4 LinearMix(vec4 v1, vec4 v2, float Between0And1)
{
    return (v1 * (1 - Between0And1)) + (v2 * Between0And1);
}

float RandHash(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float RandomOnRange0To1(vec2 hashInput)
{
    return RandHash(hashInput);
}

float RandomOnRangeNeg1ToPos1(vec2 hashInput1, vec2 hashInput2)
{
    if (RandomOnRange0To1(hashInput1) < 0.5)
    {
        return -1.0 * RandomOnRange0To1(hashInput2);
    }
    else
    {
        return +1.0 * RandomOnRange0To1(hashInput2);
    }
}

uniform mat4 uWindowSpaceRegionTransform;
bool ParticleOutOfBoundsPolygon(Particle p)
{
    for (int faceIndex = 0; faceIndex < uPolygonFaceCount; faceIndex++)
    {
        PolygonFace f = PolygonRegionFaces[faceIndex];

        // for this simple calculation, either the face's start or end point will work

        //vec4 faceToParticle = p._pos - f._start._pos;
        //if (dot(faceToParticle, f._start._normal) > 0)
        //{
        //    return true;
        //}

        vec4 faceToParticle = p._pos - (uWindowSpaceRegionTransform * f._start._pos);
        vec4 rotatedNormal = uWindowSpaceRegionTransform * f._start._normal;
        if (dot(faceToParticle, rotatedNormal) > 0)
        {
            return true;
        }
    }

    return false;
}


uniform float uDeltaTimeSec;
uniform vec4 uPointEmitterCenter;
uniform float uMinParticleVelocity;
uniform float uDeltaParticleVelocity;
uniform mat4 uWindowSpaceEmitterTransform;
Particle PointEmitterResetPos(Particle p)
{
    // need a lot of differnt seeds for the "random" hash
    // Note: If the same seed is used for multiple hash summons, such as RandomOnRangeNeg1ToPos1(...), then the result will be random-ish on a limited range (learned by experience) and doesn't look good.  so I use a lot of variations of the position and velocity to generate varying hash seeds.
    vec2 posSeed1 = vec2(p._pos.x + 0.0, p._pos.y + 0.0);
    vec2 posSeed2 = vec2(p._pos.x + 1.0, p._pos.y + 0.0);
    vec2 posSeed3 = vec2(p._pos.x + 0.0, p._pos.y + 1.0);
    vec2 posSeed4 = vec2(p._pos.x + 1.0, p._pos.y + 1.0);
    vec2 velSeed1 = vec2(p._vel.x + 0.0, p._vel.y + 0.0);
    vec2 velSeed2 = vec2(p._vel.x + 1.0, p._vel.y + 0.0);
    vec2 velSeed3 = vec2(p._vel.x + 0.0, p._vel.y + 1.0);
    vec2 velSeed4 = vec2(p._vel.x + 1.0, p._vel.y + 1.0);
    vec2 posVelSeed1 = vec2(p._pos.x + 0.0, p._vel.x + 0.0);
    vec2 posVelSeed2 = vec2(p._pos.x + 1.0, p._vel.x + 0.0);
    vec2 posVelSeed3 = vec2(p._pos.x + 0.0, p._vel.x + 1.0);
    
    Particle pCopy = p;
    
    vec4 basePosition = uWindowSpaceEmitterTransform * uPointEmitterCenter;
    //vec4 basePosition = uPointEmitterCenter;
    float posX = RandomOnRangeNeg1ToPos1(posSeed1, posSeed2);
    float posY = RandomOnRangeNeg1ToPos1(posSeed3, posSeed4);

    // need to normalize the outer limit (), but to do that we can't have a 1 in the w position 
    // or else the X and Y's normalization get's messed up
    // Note: Window space is on the range [-1,+1] on X and Y, hence the normalizing.
    // Also Note: Anything with w = 1 is meant to be translated but not normalized, while any 
    // vector with w = 0 is the reverse.
    vec4 outerPosLimit = 0.1 * QuickNormalize(vec4(posX, posY, 0.0, 0.0));
    vec4 posVariance = LinearMix(uPointEmitterCenter, outerPosLimit, RandomOnRange0To1(posVelSeed1));
    pCopy._pos = basePosition + posVariance;
    
    // similar to the MinMaxVelocity::GetNew() on the CPU side
    float velocityVariation = RandomOnRange0To1(posVelSeed2) * uDeltaParticleVelocity;
    float velocityMagnitude = uMinParticleVelocity + velocityVariation;
    float velX = RandomOnRangeNeg1ToPos1(velSeed1, velSeed2);
    float velY = RandomOnRangeNeg1ToPos1(velSeed3, velSeed4);
    vec4 randomVelocityVector = QuickNormalize(vec4(velX, velY, 0.0, 0.0));
    pCopy._vel = randomVelocityVector * velocityMagnitude;
    
    return pCopy;
}


uniform vec4 uBarEmitterP1;
uniform vec4 uBarEmitterP2;
Particle BarEmitterReset(Particle p)
{
    return p;
}



void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uMaxParticleCount)
    {
        Particle p = AllParticles[index];

        vec4 deltaPosition = p._vel * uDeltaTimeSec;
        p._pos = p._pos + deltaPosition;

        // if it went out of bounds, reset it
        if (ParticleOutOfBoundsPolygon(p))
        {
            p = PointEmitterResetPos(p);
        }

        // TODO: new algorithm with atomic counters for "particles emitted per emitter per frame":
        // if (out of bounds) > set "is active" = 0
        // if (atomic counter < max particles per frame this emitter) > reset particle to emitter in use
        //??how to use an atomic counter??
        // ??how to reset an atomic counter for a compute shader in use and not affect the already-dispatched compute shader??


        AllParticles[index] = p;
    }
}

